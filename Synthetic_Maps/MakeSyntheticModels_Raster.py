# -*- coding: utf-8 -*-
"""
Created on Tue Mar 21 11:13:51 2023

@author: oakley

Create synthetic models of similar folds with topography generated by 
Perlin noise and export the resulting maps in raster format.

This uses a grid size of 12750 x 12750 m so that it is 256 x 256 pixels when a 50 m pixel size is used.
"""

import numpy as np
import matplotlib.pyplot as plt
from FoldFunction import fold
import PerlinNoise as ns
import os

def MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry=None, sigmoid_amplitude=None, sigmoid_steepness=None,sigmoid_scale=None, topo_type='Perlin'):
    #Since a lot of things are the same for all these synthetic models, use this function to do them without repeating code.
    
    # crs = 'epsg:2154' #Coordinate reference system to use for the shape file.

    # pyproj.datadir.set_data_dir('C:\\Users\\oakley\\Anaconda3\\envs\\gdal_test\\Library\\include\\proj')

    #Define the grid.
    cell_size = 50.0 #meters
    xmin,xmax = [0,12750] #This is done so with 50 m cells it has dimensions 256x256, which is what is used for training the U-NET.
    ymin,ymax = [0,12750]
    xvec = np.arange(xmin,xmax+cell_size,cell_size)
    yvec = np.arange(ymin,ymax+cell_size,cell_size)
    X, Y = np.meshgrid(xvec, yvec, indexing='ij')
    
    #Define the units.
    #There are 7 units here.
    z0 = 0.0 #Elevation of top of lowest unit.
    nhorizons = 7
    # thicknesses = [500.0,1700.0,1000.0,600.0,300.0,500.0] #This should have length nhorizons-1
    thicknesses = [425.0,1445.0,850.0,510.0,255.0,425.0] #Scaled by 0.85 from synthetic_maps6, like everything else in this version.
    
    #Create a list of all the unit top elevations.
    horizons = [z0*np.ones(X.shape)]
    z = z0
    for i in range(nhorizons-1):
        z += thicknesses[i]
        horizons.append(z*np.ones(X.shape))
    
    #Set information about the folds that may not have been included.
    nfolds = len(xwavelength)
    if asymmetry is None:
        asymmetry = [0]*nfolds
    if sigmoid_amplitude is None:
        sigmoid_amplitude = [0]*nfolds
    if sigmoid_steepness is None:
        sigmoid_steepness = [0]*nfolds
    if sigmoid_scale is None:
        sigmoid_scale = [0]*nfolds
    
    uplift = np.zeros(X.shape)
    axis_in_cell = np.zeros(X.shape,dtype=bool)
    fold_area = np.zeros(X.shape,dtype=bool)
    fold_axis = []
    fold_area_poly = []
    for j in range(nfolds):
        uplift_new,axis_in_cell_new, fold_area_new, fold_axis_new, fold_area_poly_new = fold(X,Y,cell_size,xc[j],yc[j],amplitude[j],xwavelength[j],vergence[j],
                                                                                             plunge_wavelength = ywavelength[j],asymmetry = asymmetry[j],
                                                                                             sigmoid_amplitude = sigmoid_amplitude[j], 
                                                                                             sigmoid_steepness = sigmoid_steepness[j],
                                                                                             sigmoid_scale = sigmoid_scale[j])
        uplift += uplift_new
        fold_area = fold_area | fold_area_new
        axis_in_cell = axis_in_cell | axis_in_cell_new
        fold_axis.append(fold_axis_new)
        fold_area_poly.append(fold_area_poly_new)
    
    #Fold all the horizons.
    for i in range(nhorizons):
        horizons[i] += uplift
    
    if topo_type == 'eggbox':
        #Define the parameters of the egg box function.
        # amplitude = 500.0
        # wavelength = 1000
        # mean_elevation = 4000.0
        amplitude = 425.0
        wavelength = 850
        mean_elevation = 3400.0
        a = amplitude/2.0
        b = wavelength/2.0

        #Generate the topography.
        topo = mean_elevation + a*(np.sin(X/b)+np.sin(Y/b)) #Mean elevation plus an egg box function.
        
    elif topo_type == 'none':
        # topo = 4000*np.ones(X.shape)
        topo = 3400*np.ones(X.shape)
        
    else: #The regular Perlin noise topography.
        #Define the geometry and the Perlin noise parameters
        shape = (X.shape)
        scale = max(shape)
        octaves = 6
        persistence = 0.5
        lacunarity = 2.0
        # base = 200
        base = 90
        
        #Generate the Perlin noise.
        topo = ns.perlin_grid(shape[0], shape[1], frequency=scale, base=base, octaves=octaves, lacunarity=lacunarity, persistence=persistence)
        
        #Convert topography to a scale appropriate to the Noddy model and plot it.
        # topo = topo*800.0+4000.0
        topo = topo*680.0+3400.0
        
    # #Plot the 3D model
    # fig = plt.figure()
    # ax = fig.add_subplot(projection='3d')
    # for i in range(nhorizons):
    #     ax.plot_surface(X, Y, horizons[i])
    # ax.axis('equal')
    
    # Plot the topography.
    # ax.plot_surface(X, Y, topo)
    # plt.figure()
    # plt.imshow(topo.T)
    # plt.colorbar()
    # plt.axis('equal')
    
    #Calculate at each point on the topography what the original elevation was by 
    #subtracting the uplift.
    orig_elev = topo-uplift
    
    #Calculate which unit each topographic point is part of.
    levels = np.cumsum([z0]+thicknesses) #orig_elev values for the horizon tops.
    unit = np.zeros(X.shape)
    for i in range(nhorizons+1):
        if i == 0:
            mask = orig_elev < levels[0]
        elif i == nhorizons:
            mask = orig_elev >= levels[-1]
        else:
            mask = (orig_elev >= levels[i-1]) & (orig_elev < levels[i])
        unit[mask] = i+1 #Unit numbers start with 1, not 0
    if np.any(unit == 0.0):
        print('Error: Some grid points have no assigned unit.')
        
    #Renumber as relative ages, so lowest number is youngest.
    strat_nums = nhorizons-np.array(unit)+1

    #Create a folder to save things to.
    directory = './'+name
    if not os.path.exists(directory):
        os.makedirs(directory)

    #Save the model.
    np.savez(directory+'/'+name+'_raster',unit=strat_nums,topo=topo,axis=axis_in_cell,area=fold_area)

    #Make a plot.
    plt.figure()
    plt.subplot(2,2,1)
    plt.imshow(topo.T,origin='lower')
    plt.subplot(2,2,2)
    plt.imshow(unit.T,origin='lower')
    plt.subplot(2,2,3)
    plt.imshow(axis_in_cell.T,origin='lower')
    plt.subplot(2,2,4)
    plt.imshow(fold_area.T,origin='lower')
    

#Single fold:
name = 'SingleFold'
xwavelength = [3.4e3]
# ywavelength = [10.2e3]
ywavelength = [11500]
amplitude = [2125]
vergence = [30.0]
xc = [6375]
yc = [6375]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Single fold with eggbox topography:
#(Keep everything else from SingleFold)
name = 'SingleFold_EggBoxTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, topo_type='eggbox')

#Asymmetric fold:
#(Keep everything else from SingleFold)
name = 'AsymmetricFold'
asymmetry = [0.5] #This is defined as the ratio of the shorter wavelength to the longer wavelength.
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry = asymmetry)

#Sigmoidal fold:
#(Keep everything else from SingleFold)
name = 'SigmoidalFold'
sigmoid_amplitude = [680]
# sigmoid_steepness = [1]
sigmoid_steepness = [1.15]
sigmoid_scale = [850]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, sigmoid_amplitude=sigmoid_amplitude, sigmoid_steepness=sigmoid_steepness,sigmoid_scale=sigmoid_scale)

#Two anticline model:
name = 'DoubleFold'
xwavelength = [4e3,4e3]
ywavelength = [12e3,10e3]
amplitude = [2.5e3,1.75e3]
vergence = [20.0,20.0]
xc = [5.0e3,5.0e3+xwavelength[0]*np.cos(vergence[0]*np.pi/180.0)] #Center point of the fold (xc,yc).
yc = [5.0e3,5.0e3+xwavelength[0]*np.sin(vergence[0]*np.pi/180.0)]
asymmetry = [0.8,0.0]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc,asymmetry)

#Two anticline model, but without topography:
name = 'DoubleFold_NoTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry=asymmetry, topo_type='none')

#Multiple folds model.
name = 'MultipleFolds'
xwavelength = [3.4e3,3.4e3,2.55e3,3.4e3,2.55e3]
ywavelength = [8.5e3,8.5e3,6.8e3,6.8e3,6.8e3]
amplitude = [2125,2550,1275,2125,1275]
vergence = [0.0]*5
xc = [4675,8075,3400,6375,9775]
yc = [4250,4250,10200,10200,10200]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Multiple folds model, but with eggbox topography.
name = 'MultipleFolds_EggBoxTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, topo_type='eggbox')

#Train of 3 identical folds.
name = 'FoldTrain'
xwavelength = [2550]*3
ywavelength = [8500]*3
amplitude = [1275]*3
vergence = [0.0]*3
xc = [3.4e3,5.95e3,8.5e3]
yc = [6.375e3]*3
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Flat model.
name = 'FlatModel'
xwavelength = []
ywavelength = []
amplitude = []
vergence = []
xc = []
yc = []
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Flat model, but with eggbox topography.
name = 'FlatModel_EggBoxTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, topo_type='eggbox')