# -*- coding: utf-8 -*-
"""
Created on Tue Mar 21 11:13:51 2023

@author: oakley

Create synthetic models of similar folds with topography generated by 
Perlin noise and export the resulting maps in vector format.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import RegularGridInterpolator
from shapely.geometry import Polygon
import pandas as pd
import geopandas as gpd
from FoldFunction import fold
import PerlinNoise as ns
import os

def MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry=None, sigmoid_amplitude=None, sigmoid_steepness=None,sigmoid_scale=None, topo_type='Perlin'):
    #Since a lot of things are the same for all these synthetic models, use this function to do them without repeating code.
    
    print(name)
    
    crs = 'epsg:2154' #Coordinate reference system to use for the shape file.

    #Define the grid.
    cell_size = 20.0 #meters
    xmin,xmax = [0,12750] #This is done so with 50 m cells it has dimensions 256x256, which is what is used for training the U-NET.
    ymin,ymax = [0,12750]
    xvec = np.arange(xmin,xmax+cell_size,cell_size)
    yvec = np.arange(ymin,ymax+cell_size,cell_size)
    X, Y = np.meshgrid(xvec, yvec, indexing='ij')
    
    #Define the units.
    #There are 7 units here.
    z0 = 0.0 #Elevation of top of lowest unit.
    nhorizons = 7
    # thicknesses = [500.0,1700.0,1000.0,600.0,300.0,500.0] #This should have length nhorizons-1
    thicknesses = [425.0,1445.0,850.0,510.0,255.0,425.0] #Scaled by 0.85 from synthetic_maps6, like everything else in this version.
    
    #Create a list of all the unit top elevations.
    horizons = [z0*np.ones(X.shape)]
    z = z0
    for i in range(nhorizons-1):
        z += thicknesses[i]
        horizons.append(z*np.ones(X.shape))
    
    #Set information about the folds that may not have been included.
    nfolds = len(xwavelength)
    if asymmetry is None:
        asymmetry = [0]*nfolds
    if sigmoid_amplitude is None:
        sigmoid_amplitude = [0]*nfolds
    if sigmoid_steepness is None:
        sigmoid_steepness = [0]*nfolds
    if sigmoid_scale is None:
        sigmoid_scale = [0]*nfolds
    
    uplift = np.zeros(X.shape)
    axis_in_cell = np.zeros(X.shape,dtype=bool)
    fold_area = np.zeros(X.shape,dtype=bool)
    fold_axis = []
    fold_area_poly = []
    for j in range(nfolds):
        uplift_new,axis_in_cell_new, fold_area_new, fold_axis_new, fold_area_poly_new = fold(X,Y,cell_size,xc[j],yc[j],amplitude[j],xwavelength[j],vergence[j],
                                                                                             plunge_wavelength = ywavelength[j],asymmetry = asymmetry[j],
                                                                                             sigmoid_amplitude = sigmoid_amplitude[j], 
                                                                                             sigmoid_steepness = sigmoid_steepness[j],
                                                                                             sigmoid_scale = sigmoid_scale[j])
        uplift += uplift_new
        fold_area = fold_area | fold_area_new
        axis_in_cell = axis_in_cell | axis_in_cell_new
        fold_axis.append(fold_axis_new)
        fold_area_poly.append(fold_area_poly_new)
    
    #Fold all the horizons.
    for i in range(nhorizons):
        horizons[i] += uplift
    
    if topo_type == 'eggbox':
        #Define the parameters of the egg box function.
        # amplitude = 500.0
        # wavelength = 1000
        # mean_elevation = 4000.0
        amplitude = 425.0
        wavelength = 850
        mean_elevation = 3400.0
        a = amplitude/2.0
        b = wavelength/2.0

        #Generate the topography.
        topo = mean_elevation + a*(np.sin(X/b)+np.sin(Y/b)) #Mean elevation plus an egg box function.
        
    elif topo_type == 'none':
        #topo = 4000*np.ones(X.shape)
        topo = 3400*np.ones(X.shape)
        
    else: #The regular Perlin noise topography.
        #Define the geometry and the Perlin noise parameters
        shape = (X.shape)
        scale = max(shape)
        octaves = 6
        persistence = 0.5
        lacunarity = 2.0
        # base = 200
        base = 90
        
        #Generate the Perlin noise.
        topo = ns.perlin_grid(shape[0], shape[1], frequency=scale, base=base, octaves=octaves, lacunarity=lacunarity, persistence=persistence)
        
        #Convert topography to a scale appropriate to the Noddy model and plot it.
        # topo = topo*800.0+4000.0
        topo = topo*680.0+3400.0
        
    # #Plot the 3D model
    # fig = plt.figure()
    # ax = fig.add_subplot(projection='3d')
    # for i in range(nhorizons):
    #     ax.plot_surface(X, Y, horizons[i])
    # ax.axis('equal')
    
    # Plot the topography.
    # ax.plot_surface(X, Y, topo)
    # plt.figure()
    # plt.imshow(topo.T)
    # plt.colorbar()
    # plt.axis('equal')
    
    #Calculate at each point on the topography what the original elevation was by 
    #subtracting the uplift.
    orig_elev = topo-uplift
    
    #Contour the original elevations that correspond to the horizons.
    #Use filled contours, so we get polygons rather than lines, 
    #and extract the polygons.
    plt.figure()
    levels = np.cumsum([z0]+thicknesses) #Contour levels
    unit_vals = list(levels[:-1]+np.diff(levels)/2) #These are the values of the contour polygons between each level.
    cs = plt.contourf(X,Y,orig_elev,levels)
    
    #Plot the fold axes and areas on the plot.
    for i in range(len(fold_axis)):
        x,y = fold_axis[i].xy
        plt.plot(x,y,'k:')
    for i in range(len(fold_area_poly)):
        x,y = fold_area_poly[i].exterior.xy
        plt.plot(x,y,'k--')
    
    #Extract the contours as polygons for building the map shapefile.
    layers = cs.layers
    polygons = []
    units = []
    xvals = X[:,0].copy()
    yvals = Y[0,:].copy()
    interp_topo = RegularGridInterpolator((xvals, yvals), topo)
    plt.axis('equal')
    # interp_topo = RegularGridInterpolator((xvals, yvals), topo, method='cubic')
    #See here for the source of the code below for creating shapely polgyons from the matplotlib contours: 
    #https://gis.stackexchange.com/questions/99917/converting-matplotlib-contour-objects-to-shapely-objects
    #The above commented out code with allsegs only works if the polygons have no holes, but the code below 
    #works even with holes.
    # plt.figure()
    for i, collection in enumerate(cs.collections):
        for path in collection.get_paths():
            if path.to_polygons():
                for npoly, polypoints in enumerate(path.to_polygons()):
                    polypoints = np.round(polypoints,10) #I am sometimes getting a crash due to a very small rounding error putting a point out of bounds.
                    xc = polypoints[:, 0]
                    yc = polypoints[:, 1]
                    zc = interp_topo(polypoints)
                    # plt.scatter(xc,yc,c=zc,vmin=topo.min(),vmax=topo.max())
                    poly_init = Polygon([coords for coords in zip(xc, yc, zc)])
                    if poly_init.is_valid:
                        poly_clean = poly_init
                    else:
                        poly_clean = poly_init.buffer(0.)
                    if npoly == 0:
                        poly = poly_clean
                    else:
                        poly = poly.difference(poly_clean)
                polygons.append(poly)
                units.append(1+int(unit_vals.index(layers[i])))
    # plt.colorbar()
    # plt.axis('equal')
    
    #Create lists for columns that we will need for the fold detection algorithm.
    NAME = []
    RelAge = []
    strat_nums = nhorizons-np.array(units)+1
    #units is numbered oldest to youngest, but strat_nums is youngest to oldest, so we need to switch them.
    #However, it might make more sense to number strat_nums from oldest to youngest too.
    for i in range(len(polygons)):
        NAME.append('Unit'+str(units[i]))
        RelAge.append(strat_nums[i])
        
    #Create a GeoDataFrame.
    df = pd.DataFrame(
        {'geometry': polygons,
         'NAME': NAME,
         'RelAge': RelAge})
    gdf = gpd.GeoDataFrame(df,geometry='geometry',crs=crs)
    
    #Create a folder to save things to.
    directory = './'+name
    if not os.path.exists(directory):
        os.makedirs(directory)
    
    #Export a shape file.
    save_file = directory+'/'+name+'.shp'
    gdf.to_file(save_file,engine='pyogrio')
    
    
    #Make a cross section.
    
    #Prepare the grid of cross section points.
    cs_start = [xvec[0],3500] #Starting coordinates
    x_end = xvec[-1]
    if len(vergence)>0:
        xsec_direction = vergence[0]
    else:
        xsec_direction = 0.0
    y_end = np.tan(xsec_direction*np.pi/180)*(x_end-cs_start[0])+cs_start[1]
    cs_end = [x_end,y_end]
    cs_len = np.sqrt((cs_end[0]-cs_start[0])**2+(cs_end[1]-cs_start[1])**2)
    xvec_cs = np.arange(0.0,cs_len,cell_size)
    zvec_cs = np.arange(0,4500,cell_size)
    Xcs, Zcs = np.meshgrid(xvec_cs, zvec_cs, indexing='ij')
    interp_uplift = RegularGridInterpolator((xvals, yvals), uplift)
    x_cs = xvec_cs*np.cos(xsec_direction*np.pi/180)+cs_start[0]
    y_cs = xvec_cs*np.sin(xsec_direction*np.pi/180)+cs_start[1]
    topo_cs = interp_topo(np.stack((x_cs,y_cs),axis=-1))
    topo_cs_2D = np.tile(topo_cs,[Xcs.shape[1],1]).T #This just gives the topo value above or below each point in the cross section grid.
    uplift_cs = np.tile(interp_uplift(np.stack((x_cs,y_cs),axis=-1)),[Xcs.shape[1],1]).T
    orig_elev_cs = Zcs-uplift_cs
    
    #Plot the cross section line on the map.
    plt.plot([cs_start[0],cs_end[0]],[cs_start[1],cs_end[1]],'k')
    
    #Mask out areas above the topography.
    orig_elev_masked = orig_elev_cs.copy()
    orig_elev_masked[Zcs>topo_cs_2D] = np.nan
    
    #Contour the cross section by unit.
    plt.figure()
    cs_cs = plt.contourf(Xcs,Zcs,orig_elev_masked,levels)
    layers_cs = cs_cs.layers
    polygons_cs = []
    units_cs = []
    plt.plot(xvec_cs,topo_cs,'k')
    plt.axis('equal')
    
    #Make polygons from the contours.
    for i, collection in enumerate(cs_cs.collections):
        for path in collection.get_paths():
            if path.to_polygons():
                for npoly, polypoints in enumerate(path.to_polygons()):
                    xc = polypoints[:, 0]
                    yc = polypoints[:, 1]
                    poly_init = Polygon([coords for coords in zip(xc, yc)])
                    if poly_init.is_valid:
                        poly_clean = poly_init
                    else:
                        poly_clean = poly_init.buffer(0.)
                    if npoly == 0:
                        poly = poly_clean
                    else:
                        poly = poly.difference(poly_clean)
                polygons_cs.append(poly)
                units_cs.append(1+int(unit_vals.index(layers_cs[i])))
                
    #Export the polygons as a shape file.
    #Here, we are substituting east for direction along the cross section and  north for vertical.
    RelAge_cs = []
    strat_nums_cs = nhorizons-np.array(units_cs)+1
    #units is numbered oldest to youngest, but strat_nums is youngest to oldest, so we need to switch them.
    #However, it might make more sense to number strat_nums from oldest to youngest too.
    for i in range(len(polygons_cs)):
        RelAge_cs.append(strat_nums_cs[i])
    df_cs = pd.DataFrame(
        {'geometry': polygons_cs,
         'RelAge': RelAge_cs})
    gdf_cs = gpd.GeoDataFrame(df_cs,geometry='geometry',crs=crs)
    save_file_cs = directory+'/'+name+'_cross_section.shp'
    gdf_cs.to_file(save_file_cs)
    
    #Also save the topography and topographic profile, so we can plot them too.
    filename = directory+'/'+name+'_topo'
    np.savez(filename,topo=topo,topo_cs=topo_cs,cs_line = [cs_start,cs_end],X=X,Y=Y)
    
    #Make the fold axes and areas into geodataframes and export them as shapefiles.
    df_fold_axes = pd.DataFrame({'geometry': fold_axis})
    df_fold_areas = pd.DataFrame({'geometry': fold_area_poly})
    gdf_fold_axes = gpd.GeoDataFrame(df_fold_axes,geometry='geometry',crs=crs)
    gdf_fold_areas = gpd.GeoDataFrame(df_fold_areas,geometry='geometry',crs=crs)
    gdf_fold_axes.to_file(directory+'/'+name+'_anticline_axes.shp')
    gdf_fold_areas.to_file(directory+'/'+name+'_anticline_areas.shp')


#Single fold:
name = 'SingleFold'
xwavelength = [3.4e3]
# ywavelength = [10.2e3]
# ywavelength = [12750]
ywavelength = [11500]
amplitude = [2125]
vergence = [30.0]
xc = [6375]
yc = [6375]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Single fold with eggbox topography:
#(Keep everything else from SingleFold)
name = 'SingleFold_EggBoxTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, topo_type='eggbox')

#Asymmetric fold:
#(Keep everything else from SingleFold)
name = 'AsymmetricFold'
asymmetry = [0.5] #This is defined as the ratio of the shorter wavelength to the longer wavelength.
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry=asymmetry)

#Sigmoidal fold:
#(Keep everything else from SingleFold)
name = 'SigmoidalFold'
sigmoid_amplitude = [680]
# sigmoid_steepness = [1]
# sigmoid_steepness = [1.25]
sigmoid_steepness = [1.15]
sigmoid_scale = [850]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, sigmoid_amplitude=sigmoid_amplitude, sigmoid_steepness=sigmoid_steepness,sigmoid_scale=sigmoid_scale)

#Two anticline model:
name = 'DoubleFold'
xwavelength = [4e3,4e3]
ywavelength = [12e3,10e3]
amplitude = [2.5e3,1.75e3]
vergence = [20.0,20.0]
xc = [5.0e3,5.0e3+xwavelength[0]*np.cos(vergence[0]*np.pi/180.0)] #Center point of the fold (xc,yc).
yc = [5.0e3,5.0e3+xwavelength[0]*np.sin(vergence[0]*np.pi/180.0)]
asymmetry = [0.8,0.0]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry=asymmetry)

#Two anticline model, but without topography:
name = 'DoubleFold_NoTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, asymmetry=asymmetry, topo_type='none')

#Multiple folds model.
name = 'MultipleFolds'
xwavelength = [3.4e3,3.4e3,2.55e3,3.4e3,2.55e3]
ywavelength = [8.5e3,8.5e3,6.8e3,6.8e3,6.8e3]
amplitude = [2125,2550,1275,2125,1275]
vergence = [0.0]*5
xc = [4675,8075,3400,6375,9775]
yc = [4250,4250,10200,10200,10200]
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Multiple folds model, but with eggbox topography.
name = 'MultipleFolds_EggBoxTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, topo_type='eggbox')

#Train of 3 identical folds.
name = 'FoldTrain'
xwavelength = [2550]*3
ywavelength = [8500]*3
amplitude = [1275]*3
vergence = [0.0]*3
xc = [3.4e3,5.95e3,8.5e3]
yc = [6.375e3]*3
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)
#The cross section from this looks low-amplitude, but that's because it's located at y = 3500.

#Flat model.
name = 'FlatModel'
xwavelength = []
ywavelength = []
amplitude = []
vergence = []
xc = []
yc = []
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc)

#Flat model, but with eggbox topography.
name = 'FlatModel_EggBoxTopo'
MakeModel(name, xwavelength, ywavelength, amplitude, vergence, xc, yc, topo_type='eggbox')